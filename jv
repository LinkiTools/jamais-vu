#!/usr/bin/env python
#   Copyright 2014, 2017 David Malcolm <dmalcolm@redhat.com>
#   Copyright 2014, 2017 Red Hat, Inc.
#
#   This is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see
#   <http://www.gnu.org/licenses/>.

# Tool for working with DejaGnu output

from collections import namedtuple
import mock
import os
import re
import sys
import StringIO
import unittest

import cmdln  # in Fedora as "python-cmdln"

OUTCOMES='FAIL PASS XFAIL KFAIL XPASS KPASS UNTESTED UNRESOLVED UNSUPPORTED'.split()

############################################################################
# .sum and .log files
############################################################################

class TestId(namedtuple('TestId', ['testname', 'index'])):
    """
    A (name, index) pair, identifying e.g. one instance of
      'c-c++-common/pr83059.c  -std=c++11  (test for warnings, line 7)'
    (for which there are several in the test .sum files)
    """
    pass

class DejaFile:
    """
    Output from dejagnu, either a .log or a .sum file
    """
    def __init__(self, path):
        self.path = path
        # print('DejaFile(%r)' % self.path)

        # Mapping from TestId to outcome:
        # e.g. from the zeroth occurrence of:
        #   'libffi.call/closure_fn0.c -O0 -W -Wall (test for excess errors)'
        # to 'PASS'
        self.testid_to_outcome = {}

        # Mapping from outcome to set of TestId instances
        self.outcome_to_testids = {}
        for outcome in OUTCOMES:
            self.outcome_to_testids[outcome] = set()

        # Mapping from TestId to line index
        self.testid_to_lineidx = {}

        # Mapping from test name to last numeric index
        self.testname_to_last_index = {}

        # gcc/testsuite/ada/acats/acats.sum uses a tab rather than a space
        # e.g. 'PASS:\ta22006b\n'
        PATTERN_PAIRS = [(outcome, re.compile('^%s:\s+(\S.*)$' % outcome))
                         for outcome in OUTCOMES]
        # Parse the file and build the above dicts:
        for idx, line in enumerate(open(self.path)):
            #print(repr((idx, line)))
            for outcome, PATTERN in PATTERN_PAIRS:
                m = re.match(PATTERN, line)
                if m:
                    testname = m.group(1).rstrip()
                    if testname in self.testname_to_last_index:
                        next_index = self.testname_to_last_index[testname] + 1
                    else:
                        next_index = 0
                    testid = TestId(testname, next_index)
                    self.testname_to_last_index[testname] = next_index

                    self.testid_to_outcome[testid] = outcome
                    self.testid_to_lineidx[testid] = idx
                    self.outcome_to_testids[outcome].add(testid)
                    break # OUTCOMES loop

    def find(self, search_testname):
        result = 0
        for cand_testname in sorted(self.testname_to_outcome):
            # substring matches
            if search_testname in cand_testname:
                print('%s:%i: %s: %s'
                      % (self.path,
                         self.testname_to_lineidx[cand_testname] + 1,
                         self.testname_to_outcome[cand_testname],
                         cand_testname))
                result += 1
        return result

    def get_count_by_outcome(self, outcome):
        return len(self.outcome_to_testids[outcome])

class LogFile(DejaFile):
    """
    A .log file from dejagnu
    """
    def __init__(self, path):
        DejaFile.__init__(self, path)

    def __repr__(self):
        return 'LogFile(%r)' % self.path

class SumFile(DejaFile):
    """
    A .sum file from dejagnu
    """
    def __init__(self, path, parse_log_file=False):
        DejaFile.__init__(self, path)

        # Locate the .log file that this is a summary of:
        root, ext = os.path.splitext(path)
        self.logpath = root + '.log'

        # ...but don't parse it yet, as that's expensive:
        self.logfile = None

    def load_log_file(self):
        if not self.logfile:
            self.logfile = LogFile(self.logpath)

    def __repr__(self):
        return 'SumFile(%r)' % self.path

    def __cmp__(self, other):
        return cmp(self.path, other.path)

    def relative_path(self, basedir):
        return os.path.relpath(self.path, basedir)

    def find(self, testname):
        count = DejaFile.find(self, testname)
        if count:
            # Also find within .log file:
            self.load_log_file()
            count += self.logfile.find(testname)

        return count

    def summarize(self, tr):
        tr.begin_section(self.path)
        for outcome in OUTCOMES:
            if self.outcome_to_testids[outcome]:
                tr.writeln('%s: %i tests'
                           % (outcome, self.get_count_by_outcome(outcome)))
        tr.end_section()

class TestRun:
    """
    A collection of .sum files (and their .log files); either
    one or more individual ones, or a directory.
    """
    def __init__(self, path):
        self.path = path
        self.sumfiles = []
        if os.path.isdir(path):
            # Locate within the directory structure:
            def visit(arg, dirname, names):
                for name in sorted(names):
                    if name.endswith('.sum'):
                        sf = SumFile(os.path.join(dirname, name))
                        # print(sf.logfile.testname_to_outcome)
                        # print(sf.logfile.testname_to_lineidx)
                        # print(sf.logfile.outcome_to_testnames)
                        self.sumfiles.append(sf)
            os.path.walk(path, visit, None)
        elif path.endswith('.sum'):
            # Locate individual file:
            sf = SumFile(path)
            self.sumfiles.append(sf)
        else:
            raise ValueError('expected a directory or a .sum file')

    def make_dict_by_rel_path(self):
        result = {}
        for sumfile in self.sumfiles:
            result[sumfile.relative_path(self.path)] = sumfile
        return result

    def compare(self, other):
        pass

    def dump(self, tr):
        for sumfile in sorted(self.sumfiles):
            tr.begin_section(sumfile.path)
            for outcome in OUTCOMES:
                tr.begin_section('%s: %i tests'
                                 % (outcome, sumfile.get_count_by_outcome (outcome)))
                for testname in sorted(sumfile.outcome_to_testnames[outcome]):
                    tr.writeln(testname)
                tr.end_section()
            tr.end_section()

    def find(self, testname):
        count = 0
        for sumfile in sorted(self.sumfiles):
            count += sumfile.find(testname)
        return count

    def summarize(self, tr):
        for sumfile in sorted(self.sumfiles):
            sumfile.summarize(tr)

############################################################################
# Various kinds of output
############################################################################

class TextReporter:
    def __init__(self):
        self.indent = 0

    def begin_section(self, title):
        self.writeln(title)
        self.writeln('-' * len(title))
        self.writeln('')
        self.indent += 1

    def end_section(self):
        self.writeln('')
        self.indent -= 1

    def writeln(self, text):
        if text == '':
            print('')
        else:
            print('%s%s' % (' ' * self.indent, text))

############################################################################
# Implementation details of "do_compare"
############################################################################

class TotalByOutcome(dict):
    def __init__(self):
        for outcome in OUTCOMES:
            self[outcome] = 0

def make_count_text(desc, countA, countB, with_percent=False):
    if countA == countB:
        return (' %s: %i'
                % (desc, countA))
    else:
        diff = countB - countA
        result = (' %s: %i->%i (%s)'
                  % (desc, countA, countB,
                     ('+%i' % diff if diff > 0 else '%i' % diff)))
        if with_percent:
            percent = countB * 100. / countA
            result += ' %2.2f%%' % percent
        return result

class Comparison:
    def __init__(self, before_path, after_path):
        self.runA = TestRun(before_path)
        self.runB = TestRun(after_path)

        self.dict_by_rel_pathA = self.runA.make_dict_by_rel_path()
        self.dict_by_rel_pathB = self.runB.make_dict_by_rel_path()

        self.relpathsA = set(self.dict_by_rel_pathA.keys())
        self.relpathsB = set(self.dict_by_rel_pathB.keys())

        self.total_by_outcomeA = TotalByOutcome()
        self.total_by_outcomeB = TotalByOutcome()

        self.issue_count = 0

    def print_missing_sum_files(self, tr):
        missing_relpaths = self.relpathsA - self.relpathsB
        if missing_relpaths:
            tr.begin_section('sum files that went away: %i'
                             % len(missing_relpaths))
            for relpath in sorted(missing_relpaths):
                sumfileA = self.dict_by_rel_pathA[relpath]
                sumfileA.summarize(tr)
                for outcome in OUTCOMES:
                    self.total_by_outcomeA[outcome] \
                        += self.sumfileA.get_count_by_outcome(outcome)
                self.issue_count += 1
            tr.end_section()

    def print_new_sum_files(self, tr):
        new_relpaths = self.relpathsB - self.relpathsA
        if new_relpaths:
            tr.begin_section('sum files that appeared: %i'
                             % len(new_relpaths))
            for relpath in sorted(new_relpaths):
                sumfileB = self.dict_by_rel_pathB[relpath]
                sumfileB.summarize(tr)
                for outcome in OUTCOMES:
                    self.total_by_outcomeB[outcome] \
                        += self.sumfileB.get_count_by_outcome(outcome)
                self.issue_count += 1
            tr.end_section()

    def compare_sum_files(self, tr):
        """Compare .sum files for which there are matching peers"""
        tr.begin_section('Comparing %i common .sum files'
                         % len(self.relpathsA & self.relpathsB))
        self.initial_summary(tr)
        tr.end_section()
        self.detailed_comparison(tr)

    def initial_summary(self, tr):
        for relpath in sorted(self.relpathsA & self.relpathsB):
            sumfileA = self.dict_by_rel_pathA[relpath]
            sumfileB = self.dict_by_rel_pathB[relpath]
            outcome_text = make_count_text('total',
                                           len(sumfileA.testid_to_outcome),
                                           len(sumfileB.testid_to_outcome))
            for outcome in OUTCOMES:
                countA = sumfileA.get_count_by_outcome(outcome)
                countB = sumfileB.get_count_by_outcome(outcome)
                if countA or countB:
                    outcome_text += make_count_text(outcome, countA, countB)
                self.total_by_outcomeA[outcome] += countA
                self.total_by_outcomeB[outcome] += countB
            tr.writeln('%s :%s' % (relpath, outcome_text))

    def detailed_comparison(self, tr):
        for relpath in sorted(self.relpathsA & self.relpathsB):
            sumfileA = self.dict_by_rel_pathA[relpath]
            sumfileB = self.dict_by_rel_pathB[relpath]

            # Compare the individual tests
            testidsA = set(sumfileA.testid_to_outcome.keys())
            testidsB = set(sumfileB.testid_to_outcome.keys())
            missing_testids = testidsA - testidsB
            if missing_testids:
                tr.begin_section('Tests that went away in %s: %i'
                                 % (relpath, len(missing_testids)))
                for testid in sorted(missing_testids):
                    tr.writeln('%s: %s'
                               % (sumfileA.testid_to_outcome[testid],
                                  testid.testname))
                    self.issue_count += 1
                tr.end_section()

            new_testids = testidsB - testidsA
            if new_testids:
                tr.begin_section('Tests appeared in %s: %i'
                                 % (relpath, len(new_testids)))
                for testid in sorted(new_testids):
                    tr.writeln('%s: %s'
                               % (sumfileB.testid_to_outcome[testid],
                                  testid.testname))
                    self.issue_count += 1
                tr.end_section()

            # dict mapping from testid to (before, after) outcome pairs
            changing = {}
            for testid in sorted(testidsA & testidsB):
                outcomeA = sumfileA.testid_to_outcome[testid]
                outcomeB = sumfileB.testid_to_outcome[testid]
                if outcomeA != outcomeB:
                    changing[testid] = (outcomeA, outcomeB)
            if changing:
                tr.begin_section('Tests changing outcome in %s: %i'
                                 % (relpath, len(changing)))
                for testid in sorted(changing.keys()):
                    outcomeA, outcomeB = changing[testid]
                    tr.writeln('%s -> %s : %s'
                               % (outcomeA, outcomeB, testid.testname))
                    self.issue_count += 1
                tr.end_section()

    def conclusion(self, tr):
        if self.relpathsA & self.relpathsB and self.issue_count == 0:
            tr.writeln('No differences found in %i common .sum files'
                       % len(self.relpathsA & self.relpathsB))
        else:
            tr.begin_section('Summary')
            tr.writeln(make_count_text('# of .sum files',
                                       len(self.relpathsA),
                                       len(self.relpathsB)))
            for outcome in OUTCOMES:
                countA = self.total_by_outcomeA[outcome]
                countB = self.total_by_outcomeB[outcome]
                if countA or countB:
                    tr.writeln(make_count_text(outcome, countA, countB,
                                               outcome == 'PASS'))
            tr.end_section()

############################################################################
# Command-line interface
############################################################################

class JV(cmdln.Cmdln):
    name = 'jv'

    def do_compare(self, subcmd, opts, before_path, after_path):
        """
        Compare a "before" run to an "after" run.
        Accepts a pair of directories, or a pair of .sum files.

        If a pair of directories, assume that they have the same
        underlying structure when peer-matching.

        Returns the number of issues found (missing .sum files,
        new failures, etc).
        """
        c = Comparison(before_path, after_path)

        tr = TextReporter()

        c.print_missing_sum_files(tr)
        c.print_new_sum_files(tr)
        c.compare_sum_files(tr)
        c.conclusion(tr)

        return c.issue_count

    def do_dump(self, subcmd, opts, *paths):
        """
        Print a dump of one or more .sum files, or directories, categorized
        by outcome.
        """
        for path in paths:
            run = TestRun(path)
            tr = TextReporter()
            run.dump(tr)

    def do_find(self, subcmd, opts, testname, *paths):
        """
        Locate a test, by name, in the given .sum files or directories.

        If a test is located in a .sum file, jv will also look for the
        test in the corresponding .log file.

        Example:
          ./jv find \
            "c-c++-common/Wcast-qual-1.c -std=gnu++11  (test for warnings, line 100)" \
            testdata/control

        Return the number of matches found
        """
        count = 0
        for path in paths:
            run = TestRun(path)
            count += run.find(testname)
        return count

    def do_summarize(self, subcmd, opts, *paths):
        """
        Print a short summary of one or more .sum files or directories.
        """
        for path in paths:
            run = TestRun(path)
            tr = TextReporter()
            run.summarize(tr)

    def do_test(self, subcmd, opts, *paths):
        """
        Run jv's own selftests.
        """
        unittest.main(argv=[sys.argv[0], '-v'])

def mock_stdout():
    return mock.patch('sys.stdout', new=StringIO.StringIO())

class TestTestRun(unittest.TestCase):
    def test_finding_sum_files_recursively(self):
        runA = TestRun('control')
        dict_by_rel_pathA = runA.make_dict_by_rel_path()
        sumfileA = dict_by_rel_pathA['g++.sum']
        self.assertEqual(sumfileA.path, 'control/g++.sum')

    def test_individual_sum_file(self):
        runA = TestRun('control/g++.sum')
        dict_by_rel_pathA = runA.make_dict_by_rel_path()
        sumfileA = dict_by_rel_pathA['.']
        self.assertEqual(sumfileA.path, 'control/g++.sum')

    def test_bogus_path(self):
        with self.assertRaisesRegexp(ValueError,
                                     'expected a directory or a .sum file'):
            runA = TestRun('Makefile')

class TestSumFile(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.sumfile = SumFile('control/g++.sum')

    def test_summarize(self):
        tr = TextReporter()
        with mock_stdout() as fake_stdout:
            self.sumfile.summarize(tr)
        self.assertEqual(fake_stdout.getvalue(),
                         'control/g++.sum\n'
                         '---------------\n'
                         '\n'
                         ' FAIL: 8 tests\n'
                         ' PASS: 119872 tests\n'
                         ' XFAIL: 434 tests\n'
                         ' UNSUPPORTED: 4697 tests\n'
                         '\n')

    def test_get_count_by_outcome(self):
        self.assertEqual(self.sumfile.get_count_by_outcome('FAIL'), 8)
        self.assertEqual(self.sumfile.get_count_by_outcome('PASS'), 119872)
        self.assertEqual(self.sumfile.get_count_by_outcome('XFAIL'), 434)
        self.assertEqual(self.sumfile.get_count_by_outcome('UNSUPPORTED'), 4697)
        self.assertEqual(self.sumfile.get_count_by_outcome('UNRESOLVED'), 0)

    def test_one_test_unique(self):
        TESTNAME \
            = 'c-c++-common/asan/alloca_big_alignment.c   -O0  execution test'
        testid = TestId(TESTNAME, 0)
        self.assertEqual(self.sumfile.testid_to_outcome[testid], 'PASS')
        self.assertIn(testid, self.sumfile.outcome_to_testids['PASS'])
        self.assertEqual(self.sumfile.testid_to_lineidx[testid], 21)

    def test_one_test_repeated(self):
        TESTNAME \
            = 'c-c++-common/pr83059.c  -std=c++11  (test for warnings, line 7)'
        # There are 3 instances of this testname, each with PASS
        for i in range(3):
            testid = TestId(TESTNAME, i)
            self.assertEqual(self.sumfile.testid_to_outcome[testid], 'PASS')
            self.assertIn(testid, self.sumfile.outcome_to_testids['PASS'])
            self.assertEqual(self.sumfile.testid_to_lineidx[testid], 18456 + i)

class TestComparison(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.c = Comparison('control', 'experiment')

    def test_print_missing_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_missing_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')
        # TODO: add a comparison where a .sum file goes away

    def test_print_new_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.print_new_sum_files(tr)
        self.assertEqual(fake_stdout.getvalue(), '')
        # TODO: add a comparison where a .sum file appears

    def test_compare_sum_files(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.compare_sum_files(tr)
        self.assertIn(' g++.sum : total: 125011->125021 (+10)'
                      ' FAIL: 8->11 (+3) PASS: 119872->119879 (+7)'
                      ' XFAIL: 434 UNSUPPORTED: 4697\n', fake_stdout.getvalue())
        self.assertIn('Tests that went away in g++.sum: 323\n',
                      fake_stdout.getvalue())
        self.assertIn('Tests appeared in g++.sum: 333\n',
                      fake_stdout.getvalue())

    def test_conclusion(self):
        with mock_stdout() as fake_stdout:
            tr = TextReporter()
            self.c.conclusion(tr)
        self.assertMultiLineEqual(fake_stdout.getvalue(),
                                  'Summary\n'
                                  '-------\n'
                                  '\n'
                                  '  # of .sum files: 1\n'
                                  '  FAIL: 8->11 (+3)\n'
                                  '  PASS: 119872->119879 (+7) 100.01%\n'
                                  '  XFAIL: 434\n'
                                  '  UNSUPPORTED: 4697\n'
                                  '\n')

if __name__ == "__main__":
    jv = JV()
    sys.exit(jv.main())
